\def\sobre{\text{\em sobre}}
\def\una{\text{\em una}}
\def\mas{\text{\em m\'{a}s}}
\def\cientifica{\text{\em cient\'{\i}fica}}
\def\aproximacion{\text{ \em aproximaci\'{o}n}}


\def\vPrsPThree{\text{\em PrsP3}}
\def\vPrsPOne{\text{\em PrsP1}}
\def\vImpPThree{\text{\em ImpP3}}
\def\adj{{\text{\em Adj}}}
\def\adv{{\text{\em Adv}}}
\def\n{\text{\em N}}
\def\pr{{\text{\em Pr}}}
\def\prn{{\text{\em Prn}}}
\def\det{{\text{\em Det}}}
\def\notDet{{\neg \text{\em Det}}}
\def\any{{\text{Any}}}


\def\sobrePr{\sobre_\pr}
\def\sobreN{\sobre_\n}

\def\unaNotDet{\una_\notDet}
\def\unaAny{\una_\any}
\def\unaPrn{\una_\prn}
\def\unaDet{\una_\det}
\def\unaPrsPThree{\una_\vPrsPThree}
\def\unaPrsPOne{\una_\vPrsPOne}
\def\unaImp{\una_\vImpPThree}
\def\aproximacionN{\aproximacion_\n}
\def\masAdv{\mas_\adv}
\def\masAdj{\mas_\adj}
\def\cientificaAdj{\cientifica_\adj}
\def\cientificaN{\cientifica_\n}

\def\cgrule#1{\noindent {\sc \bf #1 }}
\def\eqdef{\Coloneqq}

%%%%%%%%%%%%%%%

%\begin{verbatim}
% "<sobre>"
%         "sobre" pr
%         "sobre" n m sg
% "<una>"
%         "uno" prn tn f sg
%         "uno" det ind f sg
%         "unir" verb prs p3 sg
%         "unir" verb prs p1 sg
%         "unir" verb imp p3 sg
% "<aproximación>"
%         "aproximación" n f sg
% "<más>"
%         "más" adv
%         "más" adj mf sp
% "<científica>"
%         "científico" adj f sg
%         "científico" n f sg
%\end{verbatim}

%%%%%%%%%%%%%%%

%\chapter{SAT-encoding}

\section{SAT-encoding}

In this appendix, we show the translation of different rule types in detail. 
A reader who wants a general overview can read Section~\todo{write that section}.
The operations in this appendix are independent of the implementation of the software SAT-CG; it does not describe how the sentence is processed in order to find the variables.
The only purpose is to demonstrate what kind of clauses are constructed.

\section{SAT-encoding of sentences}

We demonstrate the SAT-encoding with a concrete segment in Spanish:  \emph{sobre una aproximación más científica}. It has the virtue of being ambiguous in nearly every word: for instance, \emph{sobre} is either a preposition (`above' or `about') or a noun (`envelope'); \emph{una} can be a pronoun, determiner or a verb. The full analysis, with the initial ambiguities, is shown in Figure~\ref{fig:satEncodingSpanishExample}. 

\begin{figure}[h]
\ttfamily
\centering
\begin{tabular}{ll @{\hspace{1.5cm}} ll}
"<sobre>"  &                     &                    &                         \\ 
           & "sobre" pr          &  "<aproximación>"  &                         \\
           & "sobre" n m sg      &                    & "aproximación" n f sg   \\
"<una>"    &                     &   "<más>"          &                         \\
           & "uno" prn tn f sg   &                    & "más" adv               \\
           & "uno" det ind f sg  &                    & "más" adj mf sp         \\
           & "unir" v prs p3 sg  &  "<científica>"    &                         \\
           & "unir" v prs p1 sg  &                    & "científico" adj f sg   \\
           & "unir" v imp p3 sg  &                    & "científico" n f sg     \\

\end{tabular}
\caption{Ambiguous segment in Spanish.}
\label{fig:satEncodingSpanishExample}
\end{figure}

\noindent We transform each reading into a SAT-variable:

\begin{equation}
\begin{array}{c c c c c}
\sobrePr & \unaPrn & \aproximacionN & \masAdv & \cientificaAdj \\
\sobreN  & \unaDet &                & \masAdj & \cientificaN \\
         & \unaPrsPThree \\
         & \unaPrsPOne \\
         & \unaImp \\
\end{array}
\end{equation}

\noindent CG rules may not remove the last reading, even if the conditions hold otherwise.
To ensure that each cohort contains at least one true variable, we add the following clauses:

\begin{equation}
\begin{array}{c}
\sobrePr \vee \sobreN \\
\unaPrn \vee \unaDet \vee \unaPrsPThree \vee \unaPrsPOne \vee \unaImp \\
\aproximacionN \\
\masAdv \vee \masAdj \\
\cientificaAdj \vee \cientificaN \\
\end{array}
\label{eq:atleastOneTrue}
\end{equation}

\noindent The word \emph{aproximación} is already unambiguous, thus the clause $\aproximacionN$ is a unit clause, and the respective variable is trivially assigned $True$. 
The final assignment of the other variables depends on the constraint rules.

\section{SAT-encoding of rules}

In order to demonstrate the SAT-encoding, we show variants of \textsc{remove} and \textsc{select} rules, with different contextual tests. 
We try to craft rules that make sense for this segment; however, some variants are not likely encountered in a real grammar, and for some rule types, we modify the rule slightly. We believe this makes the encoding overall more readable, in contrast to using more homogenous but more artificial rules and input.

%The basis of the rule is \texttt{REMOVE adj}, which will target the word form \emph{más}.
% Its positive counterpart is \texttt{SELECT adv}, which translates into ``remove everything but adv''.

\subsection{Unordered scheme}

We begin by introducing the unordered scheme. For basic rules, this corresponds to the encoding in \cite{lager98}; each analysis is given a single variable, and the rule application is unordered. In addition, we add rule types that \cite{lager98} does not consider.

\subsubsection{No conditions} 

The simplest rule types remove or select a target in all cases. 
A rule can target one or multiple readings in a cohort. We demonstrate the case with one target in rules~\ref{eq:rmAdj}--\ref{eq:slAdj}, and multiple target in rules~\ref{eq:rmVb}--\ref{eq:slVb}


\cgrule{REMOVE adj} Unconditionally removes all readings which contain the target.

\begin{equation}
\begin{array}{c}
\neg{}\masAdj \\
\neg{}\cientificaAdj
\end{array}
\label{eq:rmAdj}
\end{equation}

\cgrule{SELECT adj} \textsc{select} variant. Unconditionally removes all other readings that appear in the same cohort with the target.

\begin{equation}
\begin{array}{r @{~\wedge~} l }
\masAdj        & \neg{}\masAdv \\
\cientificaAdj & \neg{}\cientificaN \\
\end{array}
\label{eq:slAdj}
\end{equation}

% \cgrule{REMOVE n} A rule may not remove the last possible reading: accordingly, $\aproximacionN$ is not negated.

% \begin{equation}
% \begin{array}{c}
% \neg{}\sobreN
% \end{array}
% \label{eq:rmN}
% \end{equation}

\cgrule{REMOVE verb} As \ref{eq:rmAdj}, but matches multiple readings in a cohort. All targets are negated.

\begin{equation}
\begin{array}{c @{~\wedge~} c @{~\wedge~} c}
\neg{} \unaPrsPThree  & \neg \unaPrsPOne & \neg \unaImp
\end{array}
\label{eq:rmVb}
\end{equation}

\cgrule{SELECT verb} As \ref{eq:slAdj}, but matches multiple readings in a cohort. At least one of the target readings is true, all other readings in the same cohort are negated.

\begin{equation}
\begin{array}{c @{~\wedge~} c}
(\unaPrsPThree  \vee \unaPrsPOne \vee \unaImp) & (\neg \unaDet \wedge \neg \unaPrn) \\
\end{array}
\label{eq:slVb}
\end{equation}


\subsubsection{Positive conditions} 

Rules with contextual tests apply to the target, if the conditions hold. 
This is naturally represented as implications. We demonstrate both \textsc{remove} and {\sc select} rules with a single condition; the rest of the variants only with {\sc remove}. All rule types can be changed to {\sc select} by changing the consequent.


\begin{equation}
\begin{array}{l @{\hspace{2.5cm}} l}
\text{\cgrule{REMOVE adj IF (1 adj)}}   &  \text{\cgrule{SELECT adv IF (1 adj)}} \\
\cientificaAdj \Rightarrow \neg{}\masAdj &  \cientificaAdj \Rightarrow \masAdv \wedge \neg{}\masAdj \\
\end{array}
\end{equation}

%
% \intertext{\cgrule{REMOVE adj IF (1 adj)} Single condition, {\sc remove} variant.} 
% \cientificaAdj & \Rightarrow  \neg{}\masAdj \\
% %
% %
% \intertext{\cgrule{SELECT adv IF (1 adj)} Single condition, {\sc select} variant. Target is selected, and everything else in the reading is removed.} 
% \cientificaAdj & \Rightarrow \masAdv \wedge \neg{}\masAdj \\
%
%
\begin{align}
\intertext{\cgrule{REMOVE adj IF (1 adj) (-1 n)} Conjunction of conditions.}
\cientificaAdj \wedge \aproximacionN & \Rightarrow \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF ((1 adj)  OR (-1 n))} Disjunction of conditions (template).}
\cientificaAdj \vee \aproximacionN & \Rightarrow  \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (1C adj)} Careful context. Condition must be must be unambiguously adjective.}
\cientificaAdj \wedge \neg{}\cientificaN & \Rightarrow \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n)} Scanning. Any noun before the target is a valid condition.}
%
\sobreN \vee \aproximacionN & \Rightarrow  \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n BARRIER det)} Scanning up to a barrier. Any noun before the target, up to a determiner, is a valid condition.
%The noun reading of {\em sobre} is not a valid condition, if the determiner reading of {\em una} holds.
$\sobreN$ is a valid condition only if $\unaDet$ is false.}
%
(\sobreN \wedge \neg \unaDet) \vee \aproximacionN & \Rightarrow \neg{}\masAdj 
%
\intertext{\cgrule{REMOVE adj IF (-1* n CBARRIER det)} Scanning up to a careful barrier.
Any noun before the target, up to an unambiguous determiner, is a valid condition.
%A careful barrier is effectful only if it is unambiguous. In this case, {\em una} fails to work as a barrier, if any of its other analyses (pronoun or verb) is true. \\
%
Let $\unaAny$ denote the disjunction $\unaPrn \vee \unaPrsPThree \vee \unaPrsPOne \vee \unaImp$.} %Then we write the condition as follows.}
(\sobreN \wedge \unaAny) \vee \aproximacionN & \Rightarrow \neg{}\masAdj 
%
%
%
\intertext{\cgrule{REMOVE adj IF (-1C* n)} Scanning with careful context}
%
(\sobreN \wedge \neg \sobrePr) \vee \aproximacionN & \Rightarrow  \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1C* n BARRIER det)} Scanning with careful context, up to a barrier.}
%
%
(\sobreN \wedge \neg \sobrePr \wedge \neg \unaDet) \vee \aproximacionN & \Rightarrow \neg{}\masAdj 
%
\intertext{\cgrule{REMOVE adj IF (-1C* n CBARRIER det)} Scanning with careful context, up to a careful barrier.}
%
%
(\sobreN \wedge \neg \sobrePr \wedge \unaAny) \vee \aproximacionN & \Rightarrow \neg{}\masAdj 
\end{align}


\subsubsection{Inverted conditions}

We demonstrate the effect of two inversion operators in the following.
The keyword NOT inverts a single contextual test, and NEGATE inverts a whole conjunction of contextual tests. 
There is a crucial difference about matching between positive and inverted conditions.
If a positive condition is out of scope or the tag is not present in the initial analysis, the rule simply does not match, and no clauses are created. For instance, the conditions `10 adj' or `-1 punct', matched against our example passage, would not result in any action.
In contrast, when an inverted condition is out of scope or unapplicable, 
that makes the action happen unconditionally.
As per VISL CG-3, the condition `NOT 10 adj' applies to all sentences where there is no 10th word from target that is adjective; including the case where there is no 10th word at all.

Inversion cannot be applied to a BARRIER condition. If one wants to express \cgrule{IF (*1 foo BARRIER $\neg$bar)}, a set complement operator must be used: \cgrule{(*) - bar}.


\begin{align}
\intertext{\cgrule{REMOVE adj IF (NOT 1 adj)} Single inverted condition.}
\neg \cientificaAdj & \Rightarrow  \neg{}\masAdj \\
%
\intertext{\cgrule{REMOVE adj IF (NOT 1 adj) (NOT -1 n)} Conjunction of inverted conditions.}
\neg \cientificaAdj \wedge \neg \aproximacionN & \Rightarrow \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (NEGATE -3 pr LINK 1 det LINK 1 n)} Negation of a conjunction of conditions.}
%
\neg \sobrePr \vee \neg \unaDet \vee \neg \aproximacionN) & \Rightarrow \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (NOT 1C adj)} Negated careful context. Condition cannot be unambiguously adjective.}
%
\cientificaN & \Rightarrow \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (NOT -1* n)} Scanning. There must be no nouns before the target.}
%
\neg \sobreN \wedge \neg \aproximacionN & \Rightarrow  \neg{}\masAdj \\
%
\intertext{\cgrule{REMOVE adj IF (NOT -1* n BARRIER det)} Scanning up to a barrier. There must be no nouns before the target, up to a determiner.}
%
(\neg \sobreN \vee \unaDet) \wedge \neg \aproximacionN & \Rightarrow \neg{}\masAdj 
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n CBARRIER det)} Scanning up to a careful barrier.}
%
(\neg \sobreN \vee \unaAny) \wedge \neg \aproximacionN & \Rightarrow \neg{}\masAdj 
%
%
%
\end{align}

\subsubsection{Non-matching inverted conditions}

Here we demonstrate a number of inverted rules, in which the contextual test does not match the example sentence. As a result, the action is performed unconditionally.

\cgrule{REMOVE adj IF (NOT 1 punct)} Single inverted condition, not present in initial analysis.
%
\cgrule{REMOVE adj IF (NOT 10 adj)} Single inverted condition, out of scope.
\cgrule{REMOVE adj IF (NOT 1 adj) (NOT -10 n)} Conjunction of inverted conditions, one out of scope.
\cgrule{REMOVE adj IF (NEGATE -3 pr LINK 1 punct)} Negation of a conjunction of conditions, some not present in initial analysis.

\begin{equation}
 \neg{}\masAdj 
\end{equation}


\subsubsection{Solving and conflict handling}

The unordered scheme uses maximisation to 


\subsection{Ordered scheme}

We continue with the ordered scheme. In contrast to the unordered scheme, ordering of the rules makes a difference: the following rule orders produce a different result.

\begin{itemize}
\item[] \begin{verbatim}
REMOVE adv IF (-1 n) ;
REMOVE adj IF (-1 n) ;
\end{verbatim}
\item[] \begin{verbatim}
REMOVE adj IF (-1 n) ;
REMOVE adv IF (-1 n) ;
\end{verbatim}
\end{itemize}

In the unordered scheme, we simply translated every applicable rule into a clause, and asked the SAT-solver to find a model that satisfies all the clauses. 
Now, we need to model a state of the sentence. The first rule accesses the initial input
by the morphological analyser, and the $n^{th}$ rule accesses the sentence after the first $n-1$ rules have been run.
Similarly to \cite{lager_nivre01}, we model this as a composition of clauses, each accessing the state produced by the previous clause.

%each time that a rule is applied to a target, a new variable for the target is created.
%This makes it possible to separate two cases: a variable assigned a value, because some rule targets it, or a variable is assigned a value, because it appears in the condition of some other rule. Most importantly, it allows us to model the effect of time.

The following is not the only possible SAT-encoding to model an ordered execution of the rules. In fact, \cite{listenmaa_claessen2015} uses a different encoding; however, we changed into the one described in the following, because it generalises to grammar analysis (see Chapter~\ref{chapterCGana}).

\subsubsection{Creating the sentence}

The main difference is that the sentence starts off with all variables assigned $True$. Contrast \ref{eq:allStartTrue} with \ref{eq:atleastOneTrue}; 

\begin{equation}
\begin{array}{c}
\sobrePr \wedge \sobreN \\
\unaPrn \wedge \unaDet \wedge \unaPrsPThree \wedge \unaPrsPOne \wedge \unaImp \\
\aproximacionN \\
\masAdv \wedge \masAdj \\
\cientificaAdj \wedge \cientificaN \\
\end{array}
\label{eq:allStartTrue}
\end{equation}

\noindent At each rule application, we create a new variable for each targeted reading. The new variable is $True$ iff 

\begin{tabular}{l l}
(a) the old variable was $True$, and & (b) the rule cannot apply: this can be because \\
                                     & ~~~~-- its conditions do not hold, or \\
                                     & ~~~~-- it would remove the last reading.
\end{tabular}

% \begin{inparaenum}
 %      \item the old variable was true, and
 %      \item the rule cannot apply, either because 
 %        \begin{inparaenum} 
 %          \item the conditions of the rule do not hold, or
 %          \item applying the rule would remove the last reading.
 %        \end{inparaenum}
 %  \end{inparaenum}
For subsequent rule applications, only the variables from the latest round are accessible: the $n^{th}$ rule may only access the variables that are created, or left unchanged, by the $n-1^{th}$ rule. 
Even if a variable was true

\begin{equation}
\begin{array}{r @{~\eqdef~} l}
\text{condsHold}     & c1 \vee c2 \vee c3 ... \\
\text{someTrgIsTrue} & r1 \vee r2 \vee r3 ... \\
\text{noOtherIsTrue} & \neg r4 \wedge \neg r5 ... \\
\text{onlyTrgLeft}   & \text{someTrgIsTrue} \wedge \text{noOtherIsTrue} \\
\text{cannotApply}   & \neg \text{condsHold} \vee \text{onlyTrgLeft} \\
%
\text{New variable } trg' &  trg \wedge \text{cannotApply}
              %  [ andl s newTrgName [ oldTrgLit     --wN<a> was also true, and
              %                      , cannotApply ] --rule cannot apply 
              %     | oldTrgLit <- trgPos
              %     , let newTrgName = show oldTrgLit ++ "'" ]
\end{array}
\end{equation}

\subsubsection{No conditions} 


\cgrule{REMOVE adj} Unconditionally removes all readings which contain the target.

\begin{equation}
\centering
  %\begin{array}{r @{~\eqdef~} l}
    % \mas{}'_\adj        & \text{New variable} \\
    % \cientifica{}'_\adj &  \text{New variable} \\
    % \multicolumn{2}{c}{\neg{}\mas{}'_\adj}  \\
    % \multicolumn{2}{c}{\neg{}\cientifica{}'_\adj}
%
  \begin{array}{c}
    \text{New variable } \mas{}'_\adj \\
    \text{New variable } \cientifica{}'_\adj \\
    \neg{}\mas{}'_\adj  \\
    \neg{}\cientifica{}'_\adj
  \end{array}
\end{equation}

\cgrule{SELECT adj} \textsc{select} variant. Unconditionally removes all other readings that appear in the same cohort with the target.

\begin{equation}
\begin{array}{r @{~\wedge~} l }
\masAdj        & \neg{}\masAdv \\
\cientificaAdj & \neg{}\cientificaN \\
\end{array}
\label{eq:slAdjUnordered}
\end{equation}



\subsubsection{Positive conditions}