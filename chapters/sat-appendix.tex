\def\sobre{\text{\em sobre}}
\def\una{\text{\em una}}
\def\mas{\text{\em m\'{a}s}}
\def\cientifica{\text{\em cient\'{\i}fica}}
\def\aproximacion{\text{ \em aproximaci\'{o}n}}


\def\vPrsPThree{\text{\em PrsP3}}
\def\vPrsPOne{\text{\em PrsP1}}
\def\vImpPThree{\text{\em ImpP3}}
\def\adj{{\text{\em Adj}}}
\def\adv{{\text{\em Adv}}}
\def\n{\text{\em N}}
\def\pr{{\text{\em Pr}}}
\def\prn{{\text{\em Prn}}}
\def\det{{\text{\em Det}}}


\def\sobrePr{\sobre_\pr}
\def\sobreN{\sobre_\n}
\def\unaPrn{\una_\prn}
\def\unaDet{\una_\det}
\def\unaPrsPThree{\una_\vPrsPThree}
\def\unaPrsPOne{\una_\vPrsPOne}
\def\unaImp{\una_\vImpPThree}
\def\aproximacionN{\aproximacion_\n}
\def\masAdv{\mas_\adv}
\def\masAdj{\mas_\adj}
\def\cientificaAdj{\cientifica_\adj}
\def\cientificaN{\cientifica_\n}

\def\cgrule#1{\noindent {\sc \bf #1 }}

\appendix
\chapter{SAT-encoding}

\section{SAT-encoding of sentences}

We receive input from the morphological analyser in the following format.
The example segment is used throughout this appendix.

\begin{verbatim}
"<sobre>"
        "sobre" pr
        "sobre" n m sg
"<una>"
        "uno" prn tn f sg
        "uno" det ind f sg
        "unir" verb prs p3 sg
        "unir" verb prs p1 sg
        "unir" verb imp p3 sg
"<aproximación>"
        "aproximación" n f sg
"<más>"
        "más" adv
        "más" adj mf sp
"<científica>"
        "científico" adj f sg
        "científico" n f sg
\end{verbatim}

We transform each reading into a SAT-variable:


\begin{equation}
\begin{array}{c c c c c}
\sobrePr & \unaPrn & \aproximacionN & \masAdv & \cientificaAdj \\
\sobreN  & \unaDet &                & \masAdj & \cientificaN \\
         & \unaPrsPThree \\
         & \unaPrsPOne \\
         & \unaImp \\
\end{array}
\end{equation}

Then, for each cohort, we require that at least one of its readings is true. We add the following clauses:

\begin{equation}
\begin{array}{c}
\sobrePr \vee \sobreN \\
\unaPrn \vee \unaDet \vee \unaPrsPThree \vee \unaPrsPOne \vee \unaImp \\
\aproximacionN \\
\masAdv \vee \masAdj \\
\cientificaAdj \vee \cientificaN \\
\end{array}
\end{equation}

The word \emph{aproximación} is already unambiguous, thus the clause $\aproximacionN$ is a unit clause, and the respective variable is trivially assigned $True$. 
The final assignment of the other variables depends on the constraint rules.

\section{SAT-encoding of rules}

In order to demonstrate the SAT-encoding, we show variants of \textsc{remove} and \textsc{select} rules, with different contextual tests. 
We try to craft rules that make sense for this passage; however, some variants are not likely encountered in a real grammar, and for some rule types, we modify the rule slightly. We believe this makes the encoding overall more readable, in contrast to using more homogenous but more artificial rules and input.

%The basis of the rule is \texttt{REMOVE adj}, which will target the word form \emph{más}.
% Its positive counterpart is \texttt{SELECT adv}, which translates into ``remove everything but adv''.

\subsection{Unordered scheme}



\subsubsection{No conditions} 

The simplest rule types remove or select a target in all cases. 
A rule can target one or multiple readings in a cohort. We demonstrate the case with one target in rules~\ref{eq:rmAdj}--\ref{eq:slAdj}, and multiple target in rules~\ref{eq:rmVb}--\ref{eq:slVb}


\cgrule{REMOVE adj}

\begin{equation}
\begin{array}{c}
\neg{}\masAdj \\
\neg{}\cientificaAdj
\end{array}
\label{eq:rmAdj}
\end{equation}

\cgrule{SELECT adj}
The \textsc{select} counterpart removes all other readings that appear in the same cohort with an adjective.

\begin{equation}
\begin{array}{r @{~\wedge~} l }
\masAdj        & \neg{}\masAdv \\
\cientificaAdj & \neg{}\cientificaN \\
\end{array}
\label{eq:slAdj}
\end{equation}


\noindent 

\cgrule{REMOVE verb}

\begin{equation}
\begin{array}{c @{~\wedge~} c @{~\wedge~} c}
\neg{} \unaPrsPThree  & \neg \unaPrsPOne & \neg \unaImp
\end{array}
\label{eq:rmVb}
\end{equation}

\cgrule{SELECT verb}

\begin{equation}
\begin{array}{c @{~\wedge~} c}
(\unaPrsPThree  \vee \unaPrsPOne \vee \unaImp) & (\neg \unaDet \wedge \neg \unaPrn) \\
\end{array}
\label{eq:slVb}
\end{equation}


\subsubsection{Positive conditions} 

Rules with contextual tests apply to the target, if the conditions hold.
This is naturally represented as implications. We demonstrate both \textsc{remove} and {\sc select} rules with a single condition; the rest of the variants only with {\sc remove}. All rule types can be changed to {\sc select} by changing the consequent.


\noindent \begin{align}
%
\intertext{\cgrule{REMOVE adj IF (1 adj)} Single condition } 
\cientificaAdj & \Rightarrow  \neg{}\masAdj \\
%
%
\intertext{\cgrule{SELECT adv IF (1 adj)} Single condition, \textsc{select} variant} 
\cientificaAdj & \Rightarrow \masAdv \wedge \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (1 adj) (-1 n)} Conjunction of conditions}
\cientificaAdj \wedge \aproximacionN & \Rightarrow \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF ((1 adj)  OR (-1 n))} Disjunction of conditions (template)}
\cientificaAdj \vee \aproximacionN & \Rightarrow  \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (1C adj)} Careful context}
\cientificaAdj \wedge \neg{}\cientificaN & \Rightarrow \masAdv \wedge \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n)} Scanning}
%
%
\sobreN \vee \aproximacionN & \Rightarrow \masAdv \wedge \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n BARRIER det)} Scanning up to a barrier}
%
%
(\sobreN \wedge \neg \unaDet) \vee \aproximacionN & \Rightarrow \masAdv \wedge \neg{}\masAdj 
%
\end{align}



%\cgrule{NOT}


\subsection{Ordered scheme}
