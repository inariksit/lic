\def\sobre{\text{\em sobre}}
\def\una{\text{\em una}}
\def\aproximacion{\text{ \em aproximaci\'{o}n}}
\def\mas{\text{\em m\'{a}s}}
\def\cientifica{\text{\em cient\'{\i}fica}}


\def\vPrsPThree{\text{\sc PrsP3}}
\def\vPrsPOne{\text{\sc PrsP1}}
\def\vImpPThree{\text{\sc ImpP3}}
\def\adj{{\text{\sc Adj}}}
\def\adv{{\text{\sc Adv}}}
\def\n{\text{\sc N}}
\def\pr{{\text{\sc Pr}}}
\def\prn{{\text{\sc Prn}}}
\def\det{{\text{\sc Det}}}
\def\notDet{{\neg \text{\sc Det}}}
\def\any{{\text{Any}}}


\def\sobrePr{\sobre_\pr}
\def\sobreN{\sobre_\n}

\def\unaNotDet{\una_\notDet}
\def\unaAny{\una_\any}
\def\unaPrn{\una_\prn}
\def\unaDet{\una_\det}
\def\unaPrsPThree{\una_\vPrsPThree}
\def\unaPrsPOne{\una_\vPrsPOne}
\def\unaImp{\una_\vImpPThree}
\def\aproximacionN{\aproximacion_\n}
\def\masAdv{\mas_\adv}
\def\masAdj{\mas_\adj}
\def\cientificaAdj{\cientifica_\adj}
\def\cientificaN{\cientifica_\n}

\def\cgrule#1{\noindent {\bf  #1 }}
\def\eqdef{\Coloneqq}
\def\impl{\quad\Longrightarrow\quad}

\def\ob#1{\overbrace{ #1 \rule{0pt}{2ex}}}


%%%%%%%%%%%%%%%

%\begin{verbatim}
% "<sobre>"
%         "sobre" pr
%         "sobre" n m sg
% "<una>"
%         "uno" prn tn f sg
%         "uno" det ind f sg
%         "unir" verb prs p3 sg
%         "unir" verb prs p1 sg
%         "unir" verb imp p3 sg
% "<aproximación>"
%         "aproximación" n f sg
% "<más>"
%         "más" adv
%         "más" adj mf sp
% "<científica>"
%         "científico" adj f sg
%         "científico" n f sg
%\end{verbatim}

%%%%%%%%%%%%%%%

%\chapter{SAT-encoding}


\noindent In this appendix, we show the SAT-encoding for all the rule types that 
SAT-CG supports: {\sc remove} and {\sc select} rules, with various operations in the conditions. We show both unordered and ordered variants of SAT-CG.

The encoding in this appendix is independent of the implementation of the software SAT-CG; it does not describe how the sentence is processed in order to find the variables.

The purpose of this appendix is to give a full description of the different rule types; the method is introduced with more pedagogical focus in Section~\ref{sec:CGSAT}. 
%However, the examples in this appendix are self-contained; if you know my previous stuff and want to be bored, just read this!


\section{SAT-encoding of sentences}

As in Section~\ref{sec:CGSAT}, we demonstrate the SAT-encoding with a concrete segment in Spanish:  \emph{sobre una aproximación más científica}. 
It has the virtue of being ambiguous in nearly every word: for instance, \emph{sobre} is either a preposition (`above' or `about') or a noun (`envelope'); \emph{una} can be a pronoun, determiner or a verb. The full analysis, with the initial ambiguities, is shown in Figure~\ref{fig:satEncodingSpanishExample}. 

\begin{figure}[t]
\ttfamily
\centering
\begin{tabular}{ll @{\hspace{1.5cm}} ll}
"<sobre>"  &                     &                    &                         \\ 
           & "sobre" pr          &  "<aproximación>"  &                         \\
           & "sobre" n m sg      &                    & "aproximación" n f sg   \\
"<una>"    &                     &   "<más>"          &                         \\
           & "uno" prn tn f sg   &                    & "más" adv               \\
           & "uno" det ind f sg  &                    & "más" adj mf sp         \\
           & "unir" v prs p3 sg  &  "<científica>"    &                         \\
           & "unir" v prs p1 sg  &                    & "científico" adj f sg   \\
           & "unir" v imp p3 sg  &                    & "científico" n f sg     \\

\end{tabular}
\caption{Ambiguous segment in Spanish.}
\label{fig:satEncodingSpanishExample}
\end{figure}

\noindent We transform each reading into a SAT-variable:

\begin{equation}
\begin{array}{c c c c c}
\sobrePr & \unaPrn & \aproximacionN & \masAdv & \cientificaAdj \\
\sobreN  & \unaDet &                & \masAdj & \cientificaN \\
         & \unaPrsPThree \\
         & \unaPrsPOne \\
         & \unaImp \\
\end{array}
\end{equation}

CG rules may not remove the last reading, even if the conditions hold otherwise.
To ensure that each cohort contains at least one true variable, we add the clauses in \ref{eq:atleastOneTrue}; later referred to as the ``default rule''. 
The word \emph{aproximación} is already unambiguous, thus the clause $\aproximacionN$ is a unit clause, and the respective variable is trivially assigned $True$. 
The final assignment of the other variables depends on the constraint rules.


\begin{equation}
\begin{array}{c}
\sobrePr \vee \sobreN \\
\unaPrn \vee \unaDet \vee \unaPrsPThree \vee \unaPrsPOne \vee \unaImp \\
\aproximacionN \\
\masAdv \vee \masAdj \\
\cientificaAdj \vee \cientificaN \\
\end{array}
\label{eq:atleastOneTrue}
\end{equation}


\section{SAT-encoding of rules}

In order to demonstrate the SAT-encoding, we show variants of \textsc{remove} and \textsc{select} rules, with different contextual tests. 
We try to craft rules that make sense for this segment; however, some variants are not likely encountered in a real grammar, and for some rule types, we modify the rule slightly. We believe this makes the encoding overall more readable, in contrast to using more homogenous but more artificial rules and input.

%The basis of the rule is \texttt{REMOVE adj}, which will target the word form \emph{más}.
% Its positive counterpart is \texttt{SELECT adv}, which translates into ``remove everything but adv''.

\subsection{Unordered scheme}

We begin by introducing the unordered scheme. For basic rules, this corresponds to the encoding in \cite{lager98}; each analysis is given a single variable, and all rules have access to it.
% and all the rules are applied at the same time. 
%In addition, we add rule types that \cite{lager98} does not consider.

\subsubsection{No conditions} 

The simplest rule types remove or select a target in all cases. 
A rule can target one or multiple readings in a cohort. We demonstrate the case with one target in rules~\ref{eq:rmAdj}--\ref{eq:slAdj}, and multiple target in rules~\ref{eq:rmVb}--\ref{eq:slVb}. \\


\cgrule{REMOVE adj} Unconditionally removes all readings which contain the target.

\begin{equation}
\begin{array}{c}
\neg{}\masAdj \\
\neg{}\cientificaAdj
\end{array}
\label{eq:rmAdj}
\end{equation}

\cgrule{SELECT adj} Unconditionally removes all other readings which are in the same cohort with the target.
We do not add an explicit clause for $\masAdj$ and $\cientificaAdj$: the default rule \ref{eq:atleastOneTrue} already contain $\masAdv \vee \masAdj$ and $\cientificaAdj \vee \cientificaN$, and the combination $\masAdv \vee \masAdj$ and $\neg\masAdv$ implies that $\masAdj$ must be true. 

\begin{equation}
% \begin{array}{r @{~\wedge~} l }
% \masAdj        & \neg{}\masAdv \\
% \cientificaAdj & \neg{}\cientificaN \\
% \end{array}
\begin{array}{c}
\neg{}\masAdv \\
\neg{}\cientificaN
\end{array}
\label{eq:slAdj}
\end{equation}

% \cgrule{REMOVE n} A rule may not remove the last possible reading: accordingly, $\aproximacionN$ is not negated.

% \begin{equation}
% \begin{array}{c}
% \neg{}\sobreN
% \end{array}
% \label{eq:rmN}
% \end{equation}



\cgrule{REMOVE verb} As \ref{eq:rmAdj}, but matches multiple readings in a cohort. All targets are negated.

\begin{equation}
\begin{array}{c @{~\wedge~} c @{~\wedge~} c}
\neg{} \unaPrsPThree  & \neg \unaPrsPOne & \neg \unaImp
\end{array}
\label{eq:rmVb}
\end{equation}

\cgrule{SELECT verb} As \ref{eq:slAdj}, but matches multiple readings in a cohort. All other readings in the same cohort are negated.
As previously, we need no explicit clause for $\unaPrsPThree  \vee \unaPrsPOne \vee \unaImp$: the default rule~\ref{eq:atleastOneTrue} guarantees that at least one of the target readings is true.
% In the case of multiple targets, it could actually be harmful

\begin{equation}
\begin{array}{c @{~\wedge~} c}
\neg \unaDet & \neg \unaPrn \\
%(\unaPrsPThree  \vee \unaPrsPOne \vee \unaImp) & (\neg \unaDet \wedge \neg \unaPrn) \\
\end{array}
\label{eq:slVb}
\end{equation}


\subsubsection{Positive conditions} 

Rules with contextual tests apply to the target, if the conditions hold. 
This is naturally represented as implications. We demonstrate both \textsc{remove} and {\sc select} rules with a single condition in \ref{eq:singleCondition}; the rest of the variants only with {\sc remove}. All rule types can be changed to {\sc select} by changing the consequent from $\neg{}\masAdj$ to $\neg{}\masAdv$. %from $\neg{}\masAdj$ to $\masAdv \wedge \neg{}\masAdj$.


\begin{equation}
\begin{array}{l @{\hspace{2.5cm}} l}
\text{\cgrule{REMOVE adj IF (1 adj)}}   &  \text{\cgrule{SELECT adj IF (1 adj)}} \\
\cientificaAdj \Longrightarrow \neg{}\masAdj &  \cientificaAdj \Longrightarrow  \neg{}\masAdv \\
\end{array}
\label{eq:singleCondition}
\end{equation}

%
% \intertext{\cgrule{REMOVE adj IF (1 adj)} Single condition, {\sc remove} variant.} 
% \cientificaAdj & \impl  \neg{}\masAdj \\
% %
% %
% \intertext{\cgrule{SELECT adv IF (1 adj)} Single condition, {\sc select} variant. Target is selected, and everything else in the reading is removed.} 
% \cientificaAdj & \impl \masAdv \wedge \neg{}\masAdj \\
%
%
\begin{align}
\intertext{\cgrule{REMOVE adj IF (1 adj) (-1 n)} Conjunction of conditions.}
\cientificaAdj \wedge \aproximacionN & \impl \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF ((1 adj)  OR (-1 n))} Disjunction of conditions (template).}
\cientificaAdj \vee \aproximacionN & \impl  \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (1C adj)} Careful context. Condition must be must be unambiguously adjective.}
\cientificaAdj \wedge \neg{}\cientificaN & \impl \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n)} Scanning. Any noun before the target is a valid condition.}
%
\sobreN \vee \aproximacionN & \impl  \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n BARRIER det)} Scanning up to a barrier. Any noun before the target, up to a determiner, is a valid condition:
%The noun reading of {\em sobre} is not a valid condition, if the determiner reading of {\em una} holds.
$\sobreN$ is a valid condition only if $\unaDet$ is false.}
%
(\sobreN \wedge \neg \unaDet) \vee \aproximacionN & \impl \neg{}\masAdj 
%
\intertext{\cgrule{REMOVE adj IF (-1* n CBARRIER det)} Scanning up to a careful barrier.
Any noun before the target, up to an unambiguous determiner, is a valid condition.
The variable $\unaDet$ fails to work as a barrier, if any of the other analyses of $\una$ is true.
Let $\unaAny$ denote the disjunction $\unaPrn \vee \unaPrsPThree \vee \unaPrsPOne \vee \unaImp$.} %Then we write the condition as follows.}
(\sobreN \wedge \unaAny) \vee \aproximacionN & \impl \neg{}\masAdj 
%
%
%
\intertext{\cgrule{REMOVE adj IF (-1C* n)} Scanning with careful context}
%
(\sobreN \wedge \neg \sobrePr) \vee \aproximacionN & \impl  \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1C* n BARRIER det)} Scanning with careful context, up to a barrier.}
%
%
(\sobreN \wedge \neg \sobrePr \wedge \neg \unaDet) \vee \aproximacionN & \impl \neg{}\masAdj 
%
\intertext{\cgrule{REMOVE adj IF (-1C* n CBARRIER det)} Scanning with careful context, up to a careful barrier.}
%
%
(\sobreN \wedge \neg \sobrePr \wedge \unaAny) \vee \aproximacionN & \impl \neg{}\masAdj 
\end{align}


\subsubsection{Inverted conditions}

In the following, we demonstrate the effect of two inversion operators. 
The keyword NOT inverts a single contextual test, uch as \cgrule{IF (NOT 1 noun)}, as well as linked conditions, such as \cgrule{IF (-2 det LINK NOT *1 noun)}. The keyword NEGATE inverts a whole conjunction of contextual tests, which may have any polarity: \cgrule{IF (NEGATE -2 det LINK NOT 1 noun)} means ``there may not be a determiner followed by a not-noun''; thus, ``det noun'' would be fine, or ``prn adj'', but not ``det adj''. %a sequence which matches the whole``
Inversion cannot be applied to a BARRIER condition. If one wants to express \cgrule{IF (*1 foo BARRIER $\neg$bar)}, that is, ``try to find a \emph{foo} until you see the first item that is not \emph{bar}'', a set complement operator must be used: \cgrule{(*) - bar}.

There is a crucial difference between matching positive and inverted conditions.
If a positive condition is out of scope or the tag is not present in the initial analysis, the rule simply does not match, and no clauses are created. For instance, the conditions `10 adj' or `-1 punct', matched against our example passage, would not result in any action.
In contrast, when an inverted condition is out of scope or unapplicable, 
that makes the action happen unconditionally.
As per VISL CG-3, the condition \cgrule{NOT 10 adj} applies to all sentences where there is no 10th word from target that is adjective; including the case where there is no 10th word at all.
If we need to actually have a 10th word to the right, but that word may not be an adjective, we can, again, use the set complement: \cgrule{IF (10 (*) - adj)}.





\begin{align}
\intertext{\cgrule{REMOVE adj IF (NOT 1 adj)} Single inverted condition.}
\neg \cientificaAdj & \impl  \neg{}\masAdj \\
%
\intertext{\cgrule{REMOVE adj IF (NOT 1 adj) (NOT -1 n)} Conjunction of inverted conditions.}
\neg \cientificaAdj \wedge \neg \aproximacionN & \impl \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (NEGATE -3 pr LINK 1 det LINK 1 n)} Inversion of a conjunction of conditions.}
%
\neg \sobrePr \vee \neg \unaDet \vee \neg \aproximacionN) & \impl \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (NOT 1C adj)} Negated careful context. Condition cannot be unambiguously adjective.}
%
\cientificaN & \impl \neg{}\masAdj \\
%
%
\intertext{\cgrule{REMOVE adj IF (NOT -1* n)} Scanning. There must be no nouns before the target.}
%
\neg \sobreN \wedge \neg \aproximacionN & \impl  \neg{}\masAdj \\
%
\intertext{\cgrule{REMOVE adj IF (NOT -1* n BARRIER det)} Scanning up to a barrier. There must be no nouns before the target, up to a determiner.}
%
(\neg \sobreN \vee \unaDet) \wedge \neg \aproximacionN & \impl \neg{}\masAdj 
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n CBARRIER det)} Scanning up to a careful barrier.}
%
(\neg \sobreN \vee \unaAny) \wedge \neg \aproximacionN & \impl \neg{}\masAdj 
%
%
%
\end{align}

\subsubsection{Non-matching inverted conditions}

Here we demonstrate a number of inverted rules, in which the contextual test does not match the example sentence. As a result, the action is performed unconditionally.

\cgrule{REMOVE adj IF (NOT 1 punct)} Single inverted condition, not present in initial analysis.

\cgrule{REMOVE adj IF (NOT 10 adj)} Single inverted condition, out of scope.

\cgrule{REMOVE adj IF (NOT 1 adj) (NOT -10 n)} Conjunction of inverted conditions, one out of scope.

\cgrule{REMOVE adj IF (NEGATE -3 pr LINK 1 punct)} Inversion of a conjunction of conditions, some not present in initial analysis.

\begin{equation}
 \neg{}\masAdj 
\end{equation}


\subsubsection{Solving and conflict handling}

\todo{Move some of this long explanation to the main chapter}

The unordered scheme has a strong advantage compared to the ordered one: it can start disambiguating, even if none of the rules on its own was able to act. In addition, 

However, ignoring the order means that we miss significant information. In the unordered scheme, the different rule orders in Figure~\ref{fig:orderMatters} would be treated the same. 
Without order, they would be both applied to the word \mas, and that would cause a conflict: we cannot remove both.
With order, the problem is trivial: whichever is mentioned first, gets to apply, and removes the target. After that, the second one would not even be considered, because of the default rule, which prohibits removing the last reading.

Can we use an alternative way to handle conflicts in the unordered scheme?
Recall the notion of heuristic rule order from Section~\ref{sec:ordering}: the rules are chosen based on how well they match the context. A longer rule is a more exact match than a shorter rule, and thus preferred. The heuristic rule order is still an order, though; it does not tell us what to do, when the two rules have already created clauses.

Heuristic order asks the question ``out of all the rules that target this cohort, which one is the most exact match?'' If the competitors are \cgrule{REMOVE adj IF (-1 n)} and \cgrule{REMOVE adv IF (-1 n) (1 adj)}, then the second one will win. However, if the rules are both as good a match, which happens in Figure~\ref{fig:orderMatters}, we need to resort to mere guessing, or picking the one which is mentioned first in the rule set.

For an unordered scheme, we can ask a more complex question: ``out of all the rules that target this cohort, which one is a best fit \emph{with other rules that will apply to this whole sentence}?''
With a SAT-solver, we can answer this question. Recall that each rule application produces a formula, which is a conjunction of clauses, and in an ideal case, the whole formula is satisfiable. However, if the whole formula is unsatisfiable, we may still ask the question: give an assignment that satisfies the maximum number of the clauses. 
If the grammar is good, we hope that the interaction between the appropriate
rules would make a large set of clauses that fit together, and the
inapplicable rule would not ``fit in''.
In the SAT-world, this means that the largest number of satisfiable clauses would include the group of well-fitting rules, and leave the odd rule out.


\todo{Difference between ``condition didn't hold in the first place'' and ``two rules have the same condition and conflicting action''}


\begin{figure}
  \begin{itemize}
   \item[] \begin{verbatim}REMOVE adv IF (-1 n) ;          REMOVE adj IF (-1 n) ;
REMOVE adj IF (-1 n) ;          REMOVE adv IF (-1 n) ;\end{verbatim}
   \end{itemize}
   \caption{Two rules that target the same reading, in different orders.}
   \label{fig:orderMatters}
\end{figure}

\subsection{Ordered scheme}

We continue with the ordered scheme. In contrast to the unordered scheme, ordering of the rules makes a difference: the two rule orders in Figure~\ref{fig:orderMatters} produce a different result.

In the unordered scheme, we simply translated every applicable rule into a clause, and asked the SAT-solver to find a model that satisfies all the clauses. 
Now, we need to model a state of the sentence. The first rule accesses the initial input
by the morphological analyser, and the $n^{th}$ rule accesses the sentence after the first $n-1$ rules have been run.
Similarly to \cite{lager_nivre01}, we model this as a composition of clauses, each accessing the state produced by the previous clause.

%each time that a rule is applied to a target, a new variable for the target is created.
%This makes it possible to separate two cases: a variable assigned a value, because some rule targets it, or a variable is assigned a value, because it appears in the condition of some other rule. Most importantly, it allows us to model the effect of time.

The following is not the only possible SAT-encoding to model an ordered execution of the rules. In fact, \cite{listenmaa_claessen2015} uses a different encoding; however, we changed into the one described in the following, because it generalises to grammar analysis (see Chapter~\ref{chapterCGana}).

\subsubsection{Creating the sentence}

The main difference is that the sentence starts off with all variables assigned $True$. Contrast \ref{eq:allStartTrue} with \ref{eq:atleastOneTrue}; 

\begin{equation}
\begin{array}{c}
\sobrePr \wedge \sobreN \\
\unaPrn \wedge \unaDet \wedge \unaPrsPThree \wedge \unaPrsPOne \wedge \unaImp \\
\aproximacionN \\
\masAdv \wedge \masAdj \\
\cientificaAdj \wedge \cientificaN \\
\end{array}
\label{eq:allStartTrue}
\end{equation}

\noindent At each rule application, we create a new variable for each targeted reading. The new variable is $True$ iff 

\begin{tabular}{l l}
(a) the old variable was $True$, and & (b) the rule cannot apply: this can be because \\
                                     & ~~~~-- its conditions do not hold, or \\
                                     & ~~~~-- it would remove the last reading.
\end{tabular}

% \begin{inparaenum}
 %      \item the old variable was true, and
 %      \item the rule cannot apply, either because 
 %        \begin{inparaenum} 
 %          \item the conditions of the rule do not hold, or
 %          \item applying the rule would remove the last reading.
 %        \end{inparaenum}
 %  \end{inparaenum}
For subsequent rule applications, only the variables from the latest round are accessible: the $n^{th}$ rule may only access the variables that are created, or left unchanged, by the $n-1^{th}$ rule. 

We treat ``{\sc select} target'' rules as ``{\sc remove} all but target'', and create new variables for everything but the target. Recall that all the variables start off as true, so we need no changes in the variables to be selected. The general procedure for rules with a single condition is explained in Section~\todo{write that section}; here we show the process for all rule types, as in the unordered scheme.

% \todo{Koen, you can stop reading here, this is still crap!}

% \begin{equation}
% \begin{array}{r @{~\eqdef~} l}
% \text{condsHold}     & c1 \vee c2 \vee c3 ... \\
% \text{someTrgIsTrue} & r1 \vee r2 \vee r3 ... \\
% \text{noOtherIsTrue} & \neg r4 \wedge \neg r5 ... \\
% \text{onlyTrgLeft}   & \text{someTrgIsTrue} \wedge \text{noOtherIsTrue} \\
% \text{cannotApply}   & \neg \text{condsHold} \vee \text{onlyTrgLeft} \\
% %
% \text{New variable } trg' &  trg \wedge \text{cannotApply}
%               %  [ andl s newTrgName [ oldTrgLit     --wN<a> was also true, and
%               %                      , cannotApply ] --rule cannot apply 
%               %     | oldTrgLit <- trgPos
%               %     , let newTrgName = show oldTrgLit ++ "'" ]
% \end{array}
% \end{equation}

\subsubsection{No conditions} 


\cgrule{REMOVE adj} Unconditionally removes all readings which contain the target. We simply create a new variable with the value False.

\begin{equation}
\centering
  %\begin{array}{r @{~\eqdef~} l}
    % \mas{}'_\adj        & \text{New variable} \\
    % \cientifica{}'_\adj &  \text{New variable} \\
    % \multicolumn{2}{c}{\neg{}\mas{}'_\adj}  \\
    % \multicolumn{2}{c}{\neg{}\cientifica{}'_\adj}
%
\begin{array}{r @{~\eqdef~} l}
    \text{New variable } \mas{}'_\adj         & \text{ \em False} \\
    \text{New variable } \cientifica{}'_\adj  & \text{ \em False} \\
  \end{array}
\end{equation}

\cgrule{SELECT adj} \textsc{select} variant. Unconditionally removes all other readings that appear in the same cohort with the target.

\begin{equation}
\begin{array}{r @{~\eqdef~} l}
    \text{New variable } \mas{}'_\adv      & \text{ \em False} \\
    \text{New variable } \cientifica{}'_\n & \text{ \em False} \\
\end{array}
\label{eq:slAdjOrdered}
\end{equation}



\subsubsection{Positive conditions}

\def\invConds{\text{invalid condition}}
\def\onlyTrgLeft{\text{only target left}}

\begin{align}
%
\intertext{\cgrule{REMOVE adj IF (1 adj)} Single condition.} 
\text{New variable } \mas{}'_\adj 
      & \eqdef \masAdj\ 
        \wedge\: ( \; \ob{\neg\cientificaAdj}^{\invConds} 
        \vee  \ob{\neg\masAdv}^{\onlyTrgLeft} ) \\
%
%
\intertext{\cgrule{REMOVE adj IF (1 adj) (-1 n)} Conjunction of conditions.}
\text{New variable } \mas{}'_\adj 
      & \eqdef \masAdj\ 
       \wedge\: ( \; \ob{\neg\cientificaAdj \vee \neg\aproximacionN}^{\invConds} 
       \vee  \ob{\neg\masAdv}^{\onlyTrgLeft} ) \\
%
%
\intertext{\cgrule{REMOVE adj IF (1C adj)} Careful context. The condition for \cgrule{1C adj} is $\cientificaAdj \wedge \neg \cientificaN$; we know by the default rule that one of them must be true, so just making $\cientificaN$ positive, we negate this} %If $\cientificaN$ is true, the condition \cgrule{1C adj} does not hold.}
  \text{New variable } \mas{}'_\adj 
     & \eqdef \masAdj\ 
     \wedge\: ( \ob{\cientificaN}^{\invConds} 
     \vee \ob{\neg\masAdv}^{\onlyTrgLeft}  )  \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n)} Scanning.}
  \text{New variable } \mas{}'_\adj 
     & \eqdef \masAdj\ 
     \wedge\: ( \; \ob{\neg\cientificaN \wedge \neg\sobreN}^{\invConds} 
     \vee \ob{\neg\masAdv}^{\onlyTrgLeft} ) \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n BARRIER det)} Scanning up to a barrier. }
  \text{New variable } \mas{}'_\adj 
     & \eqdef \masAdj\ 
     \wedge\: ( \; \ob{\neg\cientificaN \wedge \neg(\sobreN \wedge \neg\unaDet)}^{\invConds} 
     \vee \ob{\neg\masAdv}^{\onlyTrgLeft} )  \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1* n CBARRIER det)} Scanning up to a careful barrier. }
  \text{New variable } \mas{}'_\adj 
     & \eqdef \masAdj\ 
     \wedge\: ( \; \ob{\neg\cientificaN \wedge \neg(\sobreN \wedge \unaAny)}^{\invConds} 
     \vee \ob{\neg\masAdv}^{\onlyTrgLeft} ) \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1C* n)} Scanning with careful context. The presence of $\sobrePr$, regardless of $\sobreN$, is enough to invalidate the C condition.}
  \text{New variable } \mas{}'_\adj 
     & \eqdef \masAdj\ 
     \wedge\: ( \; \ob{\neg\cientificaN \wedge \sobrePr}^{\invConds} 
     \vee \ob{\neg\masAdv}^{\onlyTrgLeft} ) \\
%
%
\intertext{\cgrule{REMOVE adj IF (-1C* n BARRIER det)} Scanning with careful context, up to a barrier.}
  \text{New variable } \mas{}'_\adj 
     & \eqdef \masAdj\ 
     \wedge\: ( \; \ob{\neg\cientificaN \wedge \neg(TODO)}^{\invConds} 
     \vee \ob{\neg\masAdv}^{\onlyTrgLeft} )  \\
\end{align}




